5.2 REST アーキテクチャ要素

RESTスタイルは、分散ハイパーメディアシステムにおけるアーキテクチャ要素の抽象化です。RESTは、コンポーネントの役割と他のコンポーネントとの相互作用での制約、それらがデータ要素に対して意味のある解釈を行うことに焦点を合わせるため、コンポーネントの実装とプロトコル構文の詳細を無視します。Webアーキテクチャの基礎を定義して、その結果、ネットワークベースのアプリケーションとしての振舞いの本質を定義するため、コンポーネント、コネクタとデータに対して、基本的な制約を課します。

5.2.1 データ要素

分散オブジェクトスタイル［31］と異なり、すべてのデータがカプセル化されていることと、処理コンポーネントによって隠されているアーキテクチャデータ要素の本質と状態が、RESTの特徴です。分散ハイパーメディアの本質に、この設計の原理を見ることができます。リンクが選択されると、多くの場合、情報はそれが保存された位置から使用される位置まで、人間が解読できるように動かされる必要があります。これは、他の多くの分散処理パラダイム［6, 50］と異なっています。データをプロセッサへ動かすよりも、「処理エージェント」(例えば、モバイル・コード、ストアド・プロシージャ、検索式など)をデータへ動かす方が、通常、より効率的です。

分散ハイパーメディアアーキテクトには、3つの基本的なオプションしかありません。 1) データの位置を提供し、受信者に固定フォーマットイメージを送ります。 2) レンダリングエンジンでデータをカプセル化し、両方を受信者に送ります。または、3) 受信者がレンダリングエンジンを選べるように、データ型について説明するメタデータとともに、受信者へ生データを送ります。

各オプションには、それぞれメリットとデメリットがあります。伝統的なクライアント・サーバスタイル［31］であるオプション1では、より簡単なデータ構造とクライアント実装が作られることによる憶測に反して、データの本質であるすべての情報が、送信者側に隠されたままで残ります。しかしまた、送信者にロードされる処理の大部分が、スケーラビリティの問題を引き起こし、受信者と場所の機能性を大幅に制限します。モバイルオブジェクトスタイル［50］であるオプション2では、独自のレンダリングエンジンを通してデータに特殊な処理をすることを可能にし、その間は情報隠蔽を提供しますが、そのエンジンの中に予期された受信者の機能性を制限し、データ転送量を大いに増やすかもしれません。オプション3は、バイト転送を最小化している間、送信者にシンプルさとスケーラブルであることを許容しますが、情報隠蔽の利点の影で、送信者と受信者の両方が同じデータ型を理解することを必要とします。

RESTは、標準化されたインタフェースが公開されている部分に絞って、メタデータを持つデータ型を共通に理解することに焦点を合わせることで、3つのオプションのハイブリッドを提供します。RESTのコンポーネントは、受信者の能力あるいは要望とリソースの本質に基づいて動的に選択された標準データ型の拡張セットに適合するフォーマットで、リソースの表現を転送することによって、やり取りを行います。表現を生のソースと同じフォーマットにするか、あるいは、ソースから得るかにかかわらず、インタフェースの背後に隠れて残されたものです。カプセル化されたレンダリングエンジン(例えば、Java［45］)の標準データフォーマットにおける指示を構成する表現を送ることで、モバイルオブジェクトスタイルの利点は近似されます。RESTは、サービスのカプセル化と発展を可能にするために、一般的なインタフェースを通して情報隠蔽を行い、また、ダウンロード可能な特性エンジンを通して多様な機能セットを提供することで、サーバスケーラビリティの問題なしにクライアント・サーバスタイルの関心事の分離を実現します。

RESTのデータ要素を表5-1にまとめます。

表5-1: RESTデータ要素
データ要素	現在のWebの例
リソース	ハイパーテキスト参照が目的とする対象概念
リソース識別名	URL、URN
表現	HTMLドキュメント、JPEGイメージ
メタデータ表現	メディアタイプ、最終更新日時
リソースメタデータ	ソースリンク、候補、異なるもの
制御データ	if-modified-since, cache-control

5.2.1.1 リソースとリソース識別名

RESTにおける情報の主要な抽象化は、リソースです。命名可能な情報は、どんなものでもリソースになり得ます。:ドキュメント、あるいは、イメージ、時間に関係のあるサービス(例えば、「今日のロサンゼルスの天気」)、他のリソースの収集、バーチャルでないオブジェクト(例えば、人)等。言い換えれば、作成者のハイパーテキスト参照の対象となりうるすべての概念は、リソースの定義に適合しなければなりません。リソースは、任意な特定の時点へのマッピングに対応する実体ではなく、実体を持つセットへの概念的なマッピングです。

より正確にいえば、リソースRは、時間的に異なるメンバーシップ関数MR(t)か（MR(t)は時間tを実体のセットにマッピングします)、もしくは、同等の値です。セットにおける値は、リソースの表現、あるいは、リソース識別子であるかもしれません。リソースは、その概念のどんな実現も存在する前に概念を参照することを許容する空集合に、マッピングできます。これは、Web［61］より前のほとんどのハイパーテキストシステムにとって異質である概念です。いくつかのリソースは、生成された後にいつ調べても常に同じ値セットに対応しているという意味で、静的です。他のものは、時間がたつにつれて、値が大きく変化します。リソースが静的であるために必要である唯一のものは、マッピングの意味論です。なぜなら、意味論が、そのリソースを他のものと区別するためです。

例えば、研究論文の「作者推奨版」は、時間がたつにつれて値が変化するマッピングですが、「カンファレンスXの議事で発行された論文」へのマッピングは静的です。これらは、たとえある時点で同じ値にマッピングされたとしても、2つの異なるリソースです。その区別は、両方のリソースを特定し、独立して参照できるように必要です。ソフトウェアエンジニアリングでの例として、「最新リビジョン」、「リビジョン番号1.2.7」、または「Orangeリリースで含まれたリビジョン」を参照するためのソースコードファイルバージョン管理での識別があります。

リソースのこのように抽象的な定義は、Webアーキテクチャの重要な特性を実現します。第一に、それは、型や実装によって人工的に区別することなく、情報の多様な起点を取り込むことで、一般性を提供します。第二に、リクエストの特性に基づいて行われるコンテンツネゴシエーションを可能にすることで、表現への参照の遅延バインディングを実現します。最後に、（作者が適切な識別子を使用したと仮定して）表現が変化する時に常に既存のリンクすべてを変更する必要をなくし、作者がその概念の何らかの特異な表現よりも、概念を参照することを許容します。

RESTは、コンポーネント間の相互作用にかかわるリソースを特定するために、リソース識別子を使用します。RESTコネクタは、メンバーシップ関数がどう定義されるかということや、リクエストを処理しているソフトウェアのタイプにかかわらず、リソースの値セットにアクセスして操作するために、一般的なインタフェースを提供します。リソースの参照を可能にするリソース識別子を割り当てる命名機関は、時間がたってもマッピングの意味論的正当性を維持する責任を負います（すなわち、メンバーシップ関数が変化しないことを確実にします）。

閉ざされた、もしくは、ローカルの環境で通常稼動する伝統的なハイパーテキストシステム［61］は、毎回情報変化を変えるユニークなノード、あるいは、ドキュメント識別番号を使用します。それらは、コンテンツと独立して参照を維持するため、サーバへのリンクに依存します［135］。集結されたリンクサーバは、Webの巨大なスケールとマルチ組織的なドメインリクエストで忌み嫌われるものなので、代わりにRESTは、特定される概念の本質に最も合うように作者が選択したリソース識別子に依存します。必然的に、識別子の品質は、その正当性を維持するために費やされた金額にしばしば比例し、つかの間の(あるいは、不十分なサポートの)の情報が、時間がたつにつれて移動したり見えなくなったりしてリンク切れになることにつながります。


5.2.1.2 表現

RESTコンポーネントは、リソースの現在状態、または、意図した状態を獲得するために表現を使用することと、コンポーネント間の表現を移行することで、リソースへの動作を実行します。表現は、バイトの列と、それらのバイトについて説明するメタデータである追加表現です。表現のために一般的に使用されるけれども、それほど正確でない名前は、ドキュメント、ファイル、HTTPメッセージエンティティ、インスタンス、あるいはそれらの変形です。

データから成る表現は、データについて説明するメタデータ、そして時々、メタデータ（通常、メッセージの完全性を確かめる目的のためのもの）について説明するメタデータから成ります。メタデータは、名前と値のペアの形式です。名前は、値構造と意味論を定義する規格に対応します。応答メッセージは、表現メタデータとリソースメタデータ――与えられた表現に特化しないリソースについての情報――の両方を含むかもしれません。

制御データは、要求されている動作やレスポンスの意味のように、コンポーネントの間のメッセージの目的を定義します。 また、それは、リクエストをパラメータ化して、いくつかの接続要素のデフォルトの振る舞いをオーバーライドするために使用されます。例えば、リクエストかレスポンスのメッセージに制御データを含むことによって、キャッシュの振舞いを変更できます。

メッセージ制御データによって、ある表現は、クライアントの質問フォーム内の入力データの表現、または、レスポンスのための何らかのエラー条件の表現のように、要求されたリソースの現在の状態、望ましい状態、または、ある他のリソースの値を示すかもしれません。例えば、リソースのリモートオーサリングは、作者がサーバに表現を送信し、その結果、以後のリクエストで読み出しできるリソースとして、値を確立するために必要です。リソースの値セットが一時に多重の表現から成るのであれば、コンテンツネゴシエーションは、あるメッセージに含まれる最も良い表現を選択するために、使用されるかもしれません。

表現のデータフォーマットは、メディアタイプ［48］として知られています。メッセージの制御データとメディアタイプの本質によると、表現はメッセージを含むことができ、受信者によって処理されます。あるメディアタイプは自動化された処理を目的とし、あるものはユーザに見られるようレンダリングされることを目的とし、またあるものはそれらの両方が可能です。1つのメッセージに多重の表現を包み込むために、コンポジットメディアタイプを使用できます。

メディアタイプの設計は、分散ハイパーメディアシステムにおいてユーザが体感するパフォーマンスに、直接影響を与えます。受信者が表現をレンダリングし始める前に受け取られるべきすべてのデータは、相互作用のレイテンシを加えます。残りの情報を受け取っている間に初期情報を徐々に増やしてレンダリングできるように、前もって最も重要なレンダリング情報を配置するデータフォーマットは、レンダリング開始前に完全な情報を受け取らなければならないデータフォーマットよりも、遥かに良い体感パフォーマンスをもたらします。

ネットワーク性能が同じでも、例えば、大きなHTMLドキュメントを受信している間に、それを徐々にレンダリングできるWebブラウザは、レンダリングの前に全体のドキュメントを完全に受け取るまで待つWebブラウザよりも、かなり良いユーザ体感パフォーマンスを提供します。また、コンテンツの選択によって、表現のレンダリング能力に影響を与えられることに注意してください。レンダリングの前に、テーブルと埋め込みオブジェクトのサイズが動的に決まるのであれば、ハイパーメディアページの表示エリア内で、レイテンシの増幅が起きるでしょう。

5.2.2 コネクタ

RESTは、リソースにアクセスして、リソースの表現を転送する活動をカプセル化するために、表5-2にまとめられた様々なコネクタタイプを使用します。コネクタは、明瞭な関心事の分離の提供と、リソースとコミュニケーションメカニズムの基本的な実装の隠蔽によって、シンプルさを向上させ、コンポーネントがやり取りするための抽象的なインタフェースを提示します。また、インタフェースの一般性は代替可能性をもたらします。抽象的なインタフェースを通してのみ、ユーザがシステムへアクセスできるようにすると、ユーザに影響を与えることなく、実装を交換することができます。コネクタがコンポーネントのネットワークにおけるやり取りを管理するので、効率とレスポンスを向上させるために、多様な相互作用を通して情報を共有できます。
表5-2: REST コネクタ
コネクタ	現在のWebの例
クライアント	libwww, libwww-perl
サーバ	libwww, Apache API, NSAPI
キャッシュ	browser cache, Akamai cache network
リゾルバ	bind (DNS lookup library)
トンネル	SOCKS, SSL after HTTP CONNECT

すべてのRESTの相互作用は、ステートレスです。すなわち、各リクエストは、先行してどんなリクエストがあったかにかかわらず、コネクタがリクエストを理解するのに必要な情報のすべてを含んでいます。この制限は、4つの機能を達成します。1) コネクタがリクエスト間のアプリケーション状態を保有する必要性をなくします。その結果、物理リソースの消費を抑えて、スケーラビリティを改良します。2) 処理メカニズムが相互作用を意味論的に理解する必要がなく、並行で処理することができます。3) 仲介役は、サービスが動的に再配置される時に必要になるかもしれない分離したリクエストを見て、理解します。4) 情報のすべてに、キャッシュされたレスポンスの再利用性を考慮することを、それぞれのリクエストで提示するよう強制します。

コネクタインタフェースは手続き的な呼出しと同様ですが、パラメタと結果を通すという重要な違いがあります。入力パラメタは、リクエスト制御データ、リクエスト目標を示すリソース識別子、および任意の表現から成ります。出力パラメタは、レスポンス制御データ、任意のリソースメタデータ、および任意の表現から成ります。抽象的な観点からは、呼出しは同期されますが、データ・ストリームとして出力パラメタを通すことができます。言い換えれば、パラメタの値が完全に知られる前に、処理を呼び出すことができます。その結果、大きなデータ転送のバッチ処理によるレイテンシを避けられます。

プライマリコネクタタイプは、クライアントとサーバです。2つの本質的な違いは、クライアントがリクエストすることによってコミュニケーションが開始され、その一方で、サーバがコネクションをリスンし、サービスへの接続を供給するためにリクエストに応答することです。コンポーネントは、クライアントとサーバコネクタの両方を含むかもしれません。

サードコネクタタイプ（キャッシュコネクタ）は、以後の要求された相互作用で再利用できるように、現在の相互作用でキャッシュ可能なレスポンスを蓄積するため、クライアントあるいはサーバコネクタのインタフェースに位置づけることができます。キャッシュは、ネットワークコミュニケーションの反復を避けるためにクライアントによって使用されるか、または、レスポンスを生成する処理の繰り返しを避けるためにサーバで使用される場合があります。両方のケースが、相互作用のレイテンシを減少させるのに役立ちます。キャッシュは、通常、それを使用するコネクタのアドレス空間の中で、実装されます。

いくつかのキャッシュコネクタは、共有されます。これは、キャッシュされたレスポンスが、元々得られたレスポンス以外のクライアントへの応答に使用されるかもしれないことを意味します。共有されたキャッシュは、人気があるサーバの負荷における「flash crowds」の影響を減少させる上で、有効な場合があります。特に、会社のイントラネットや、インターネットサービスプロバイダまたは大学の顧客が、全国的なネットワークバックボーンを共有するなどのように、キャッシュが大きなユーザグループをカバーするため、階層的に配置される場合、有効です。しかし、キャッシュされたレスポンスが新しいリクエストで得られたものと一致していない場合、共有されたキャッシュはエラーを引き起こします。RESTは、絶対的な透明性が常に必要であると仮定するよりも、キャッシュの振舞いにおける透明性の要求と、ネットワークの効率的な使用に関する要求とのバランスをとることを試みます。

各リソースに特化しているというよりもむしろ、インタフェースが一般的であるため、キャッシュはレスポンスのキャッシュ可能性を決定できます。デフォルトで、検索リクエストへのレスポンスは、キャッシュ可能です。そして、他のリクエストへのレスポンスは、キャッシュ可能ではありません。ユーザ認証のフォームがリクエストの一部である場合、または、レスポンスが共有されるべきでないことを示す場合、レスポンスは、単に非共有キャッシュにおいてキャッシュ可能です。コンポーネントは、キャッシュ可能、あるいは、限られた時間だけキャッシュ不可能／キャッシュ可能であるとして、相互作用をマークする制御データを含むことによって、これらのデフォルトの設定をオーバーライドすることができます。

リゾルバは、アドレス情報がインターコンポーネント接続を確立する必要があるネットワークで、部分的、あるいは完全なリソース識別子を翻訳します。 例えば、ほとんどのURIが、リソースの命名機関を特定するメカニズムとして、DNSホスト名を含んでいます。リクエストを開始する際、Webブラウザは、その機関のIPアドレスを得るために、URIからホスト名を抜粋して、DNSリゾルバを利用するでしょう。他の例として、いくつかの識別スキーマ （例えば、URN［124］）が、特定のリソースにアクセスするために、仲介役が永久的な識別子をより一時的なアドレスに翻訳することを必要とします。1つ以上の仲介役としてのリゾルバの使用は、間接指定によって、リクエストのレイテンシを加えますが、リソース参照の寿命を改良します。

コネクタタイプの最後の形態は、トンネルです。これは、接続境界の向こう側に単にコミュニケーションをリレーするファイアウォールや低レベルネットワークゲートウェイのようなものです。それがRESTの一部としてモデル化されて、ネットワークインフラの一部として遠くで奪われていない唯一の理由は、いくつかのRESTのコンポーネントが、動的コンポーネントの振舞いからトンネルに、動的に切り替わり得るためです。主な例としては、レスポンス内のトンネルをCONNECTメソッドリクエスト［71］へ切り替えることで、プロキシを許可しないTLSなどの異なるプロトコルを使ってリモートサーバと直接やり取りすることをクライアントに許容する、HTTPプロキシがあります。両端がやり取りを終えるとき、トンネルは見えなくなります。

5.2.3 コンポーネント

表5-3にまとめられたRESTコンポーネントは、全般的なアプリケーション動作における役割によって、分類されています。

表5-3: RESTコンポーネント
コンポーネント	現代のWebの例
発信元サーバ	Apache httpd, Microsoft IIS
ゲートウェイ	Squid, CGI, Reverse Proxy
プロキシ	CERN Proxy, Netscape Proxy, Gauntlet
ユーザエージェント	Netscape Navigator, Lynx, MOMspider

ユーザエージェントは、リクエストを開始するのにクライアントコネクタを使用して、レスポンスの最終的な受信者になります。 最も一般的な例が、Webブラウザです。Webブラウザは、アプリケーションのニーズに従って、情報サービスへのアクセスを提供し、サービスのレスポンスをレンダリングします。

発信元のサーバは、要求されたリソースのための名前空間を治めるのに、サーバコネクタを使用します。それは、リソースの表現のための決定的なソースであり、リソースの値を変更することを目的とするあらゆるリクエストの最終的な受信者に他なりません。それぞれの発信元サーバは、リソース階層構造として、一般的なインタフェースをサービスに提供します。リソースの実装の詳細は、インタフェースの背後に隠されます。

仲介役コンポーネントは、翻訳可能な形でリクエストとレスポンスを転送するために、クライアントとサーバの両方として機能します。プロキシコンポーネントは、他のサービス、データ変換、パフォーマンス強化、または機密保持のインタフェースのカプセル化を提供するために、クライアントによって選ばれた仲介役です。ゲートウェイ（通称、リバースプロキシ）のコンポーネントは、他のサービス、データ変換、パフォーマンス強化、機密保持のインタフェースのカプセル化を提供するために、ネットワーク、または発信元のサーバによって課された仲介役です。プロキシとゲートウェイの違いは、クライアントがいつプロキシを使用するかを決定しているかという点であることに、注意してください。

