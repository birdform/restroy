5.1 RESTの由来

Webアーキテクチャの背後にある設計の理論的根拠は、アーキテクチャ内で要素に適用される制約のセットからなるアーキテクチャスタイルによって説明されます。進化していくスタイルに加えられていった個々の制約の影響を調べることで、Webの制約によって導かれた特性を識別できます。追加の制約は、昨今のWebアーキテクチャに求められる特性を上手く反映して、新しいアーキテクチャスタイルを形成するために適用されました。本項では、アーキテクチャスタイルとしてRESTが導き出されたプロセスをたどることで、RESTの一般的な概要を提供します。以降の項では、RESTスタイルコンポーネントの制約の仕様について、より詳細に説明します。

5.1.1 Starting with the Null Style

建築物かソフトウェアかにかかわらず、アーキテクチャ設計のプロセスは、よく知られた2つの観点があります。1つ目は、設計者が何もないところ――白紙状態、ホワイトボード、落書き帳――から開始して、当該システムの必要を満たすように、使いやすいコンポーネントからアーキテクチャを組み上げる、というものです。2つ目は、設計者が、システム全体が必要とするものから制約なしに始める、というものです。識別できるものが徐々に増えて、システムとの調和の中で設計空間を区別するため、また、自然に流れるようなシステムの振る舞いを強制するために、システムの要素に制約を適用します。1つ目は、創造性と無限のビジョンを強調しており、2つ目は、拘束とシステムのコンテキストの理解を強調します。RESTは、後者のプロセスを用いて開発されています。図5-1から図5-8は、徐々に増える制約セットとしての制約が、アーキテクチャのプロセスビューをどう区別するか、という観点の図を示します。

Nullスタイル(図5-1) は、単なる制約の空のセットです。アーキテクチャの観点からいうと、Nullスタイルは、コンポーネント間に明確な境界がないシステムということになります。これが、RESTの説明の開始地点となります。

図5-1: Nullスタイル

5.1.2 クライアント・サーバ

ハイブリッドシステムに追加された最初の制約は、第3.4.1項で説明したクライアント・サーバ アーキテクチャスタイル(図5-2)でした。

関心事の分離は、クライアント・サーバの制約の背後にある原則です。ユーザインタフェースの関心事をデータストレージの関心事から分離することによって、マルチプラットフォームを横断するユーザインタフェースのポータビリティを向上させ、サーバコンポーネントの簡素化によるスケーラビリティが向上しました。ことによるとWebにとって最も意義があるのは、この分離が、独立して進化するコンポーネントを許すこと、ひいては、並列の組織的ドメインのインターネット上のスケール要求をサポートすることかもしれません。

図5-2:クライアント・サーバスタイル

5.1.3 ステートレス

クライアント・サーバの相互作用に次に加えられた制約は、コミュニケーションは本来ステートレスでなければならない、というものです。第3.4.3項（図5-3）のクライアント・ステートレス・サーバ（CSS）スタイルのように、クライアントからサーバへの個々のリクエストは、リクエストを理解するのに必要なすべての情報を含まなければならず、サーバに保存されたいかなる情報も利用できません。したがって、セッション状態は、クライアント上に完全に維持されます。

図5-3: クライアント・ステートレス・サーバスタイル

この制約は、可視性、信頼性、スケーラビリティという特性を導きます。モニタリングシステムがリクエストの完全な本質を決める上で、1つのリクエストデータを超えて監視する必要がないため、可視性が改良されています。部分的な失敗[133]からリカバリするタスクが容易になるため、信頼性が改良されています。リクエストの間の状態を保存する必要がないので、サーバコンポーネントがすぐにリソースを解放できるため、そして、複数のリクエストに渡ってリソースの使用方法をサーバが管理する必要がなくて実装がさらに簡素化されるため、スケーラビリティが改良されています。

ほとんどのアーキテクチャ上の選択と同じく、ステートレスの制約は、設計のトレードオフを反映します。デメリットは、一連のリクエストで送られた反復的なデータ（1回の相互作用あたりのオーバーヘッド）の増加によって、ネットワークパフォーマンスが低下するかもしれないことです。コンテキストを共有するサーバで、そのようなデータを残すことはできないためです。さらに、クライアント側にアプリケーション状態を置くと、一貫性のあるアプリケーションの振舞いをサーバがコントロールすることを抑えられます。これは、アプリケーションが複数のクライアントバージョン間での意味論的に正しい実装に依存するようになるためです。

5.1.4 キャッシュ

ネットワーク効率を向上させるために、第3.4.4項（図5-4）のクライアント・キャッシュ・ステートレス・サーバスタイルを形成するため、キャッシュ制約を加えます。キャッシュ制約では、リクエストへのレスポンスの中のデータが「キャッシュ可能」であるか「キャッシュ不可能」であるかを暗黙に、あるいは明確に分類することが必要です。レスポンスが「キャッシュ可能」である場合、以後の同一のリクエストのために、そのレスポンスデータを再利用する権利が、クライアントキャッシュに与えられます。
図5-4: クライアント・キャッシュ・ステートレス・サーバスタイル

キャッシュ制約を加えるメリットは、キャッシュ制約には、いくつかの相互作用を部分的または完全に排除する可能性があることです。このことは、効率、スケーラビリティ、および一連の相互作用の平均レイテンシを減少させることでユーザが体感するパフォーマンスを向上させます。トレードオフは、キャッシュ内の古いデータと、サーバへ直接送ったリクエストで得られただろうデータとに有意な差がある場合、キャッシュが信頼性を低下させることです。

図5-5［11］のダイアグラムで描かれた初期のWebアーキテクチャは、制約のクライアント・キャッシュ・ステートレス・サーバセットによって定義されました。すなわち、1994年以前のWebアーキテクチャのために提示された設計原理は、インターネット上で静的ドキュメントを交換するためのステートレス・クライアント・サーバの相互作用に、焦点を合わせていました。相互作用を伝えるためのプロトコルは、非共有キャッシュの基本的な部分をサポートしていましたが、インタフェースをすべてのリソースのための意味論の一貫したセットとして規制しませんでした。代わりに、複数のWebアプリケーションに渡って一貫性を維持するため、Webは、一般的なクライアント・サーバ実装ライブラリ(CERN libwww)の使用に依存しました。
図5-5: 初期のWWWアーキテクチャダイアグラム

Web実装の開発者は、すでに初期の設計を超えていました。静的ドキュメントに加えて、リクエストは、イメージマップ［ケビン・ヒューズ］やサーバサイドスクリプト［ロブ・マコール］のような動的生成されたレスポンスであるサービスを識別できました。仕事は、プロキシ［79］と共有キャッシュ［59］として仲介者コンポーネントで始まりましたが、信頼性のあるやり取りのためには、プロトコルへの拡張が必要でした。以下のセクションでは、昨今のWebアーキテクチャを形成する拡張を導き出すために、Webアーキテクチャスタイルに加えられた制約について、説明します。

5.1.5 統一インタフェース

RESTアーキテクチャスタイルを他のネットワークベースのスタイルと区別する上での主要な点は、コンポーネント(図5-6)の間の統一インタフェースに重きを置いていることです。一般的なソフトウェアエンジニアリングの原則をコンポーネントのインタフェースに適用することによって、全体のシステムアーキテクチャが簡素になり、相互作用の可視性が向上します。

実装は、独立した発展性を推奨することで、それらが提供するサービスから切り離されます。トレードオフは、統一インタフェースが、アプリケーションのニーズに特有の形ではなく標準化された形に情報を移すため、効率を下げることです。RESTインタフェースは、おおまかに、ハイパーメディアデータ転送において効率的になるように設計されています。Webのよくあるケースに対して最適化しますが、アーキテクチャの相互作用の他の形式には最適でないインタフェースをもたらします。
図5-6: 統一クライアント・キャッシュ・ステートレス・サーバスタイル

統一インタフェースを得るには、複数のアーキテクチャ制約が、コンポーネントの振舞いを導くために必要とされます。RESTは、4つのインタフェース制約によって定義されます。それは、リソースの識別、表現によるリソースの操作、自己記述的なメッセージ、アプリケーション状態エンジンとしてのハイパーメディアです。 第5.2節で、これらの制約について議論するでしょう。

5.1.6 レイヤー構造のシステム

インターネットのスケール要件のために振舞いをさらに改良するため、レイヤー構造の制約 (図5-7)を加えます。第3.4.2項に記述したように、レイヤー構造スタイルでは、各コンポーネントが相互作用しているすぐ隣のレイヤーを超えて「見る」ことができないように、コンポーネントの振舞いを抑制することによって、アーキテクチャを階層的なレイヤーで構成します。システムの知識を単一のレイヤーに拘束することによって、全般的なシステムの複雑さに境界を設けて、基盤の非依存性を促進します。レイヤーは、使用頻度の低い機能を共有の仲介者にすることによってコンポーネントを簡素化し、レガシーサービスをカプセル化して、レガシークライアントから新しいサービスを保護することに使用できます。 また、複数のネットワークとプロセッサをまたぐサービスのロードバランシングを可能にすることによって、システムスケーラビリティを改良するために、仲介者を使用できます。
図5-6: 統一レイヤー構造クライアント・キャッシュ・ステートレス・サーバスタイル

レイヤー構造システムの最大の難点は、オーバーヘッドとレイテンシをデータの処理に加え、ユーザが体感するパフォーマンスを抑える［32］ことです。キャッシュ制約をサポートするネットワークベースのシステムでは、仲介者役間で共有されたキャッシュの利点でこれを相殺できます。組織的なドメインの境界に共有キャッシュを設けると、大幅なパフォーマンス向上［136］がもたらされます。また、そのようなレイヤーは、ファイアウォール［79］が必要とされるように、組織的な境界に位置するデータ上でセキュリティポリシーが強制されることを許容します。

レイヤー構造と統一インタフェース制約の組み合わせは、統一パイプ-フィルタスタイル（第3.2.2項）と同様のアーキテクチャ特性を導き出します。RESTの相互作用は2-wayですが、通過するものに応じて内容を変えるために［26］、フィルタコンポーネントをデータ・ストリームに選択的に適用することで、データフローネットワークのようにハイパーメディア相互作用の大きな粒度のデータフローを処理できます。RESTでは、メッセージが自己記述的、意味論的で、仲介者から見えるものであるため、仲介者コンポーネントは活発にメッセージ内容を変えることができます。

5.1.7 コード・オンデマンド

RESTに設定された制約へ最後に追加されたものは、コード・オンデマンドスタイル（図3.5.3）からきます。RESTは、アプレットかスクリプトの形でコードをダウンロードして実行することによって、クライアントの機能が拡張されることを許容します。このことは、あらかじめ実装を必要とする機能の数を減らすことによって、クライアントをシンプルにします。開発された後にダウンロードされるという特徴を許容すると、システムの拡張性が向上します。しかしながら、それは可視性を減らすため、RESTの中の任意の制約にすぎません。
図5-8: RESTスタイル

任意の制約という概念は、矛盾のように見えるかもしれません。しかし、それには、複数の組織境界を包含するシステムにおけるアーキテクチャ設計上の目的があります。それは、システム全体の何らかの分野に有効なことが分かっているときのみ、アーキテクチャが任意の制約の恩恵(あるいは損失)を受けるという状態を実現できることを意味します。例えば、組織の中のクライアントソフトウェアのすべてがJavaアプレット［45］をサポートすることが分かっていれば、その組織の中のサービスはダウンロード可能なJavaクラスを通して機能を強化する利益を得られるよう構成することができます。しかし同時に、組織のファイアウォールは、外部ソースからのJavaアプレットの転送を防御するかもしれません。その結果、まるでそれらのクライアントがコード・オンデマンドをサポートしないWebに取り残されたもののように見えるでしょう。任意の制約は、いくつかのコンテキストでそれが無効にされるかもしれないことを理解した上で、一般的なケースで望まれる振る舞いをサポートするアーキテクチャを設計することを可能にします。

5.1.8 派生スタイルのサマリ

RESTは、候補アーキテクチャを導く特性のために選ばれたアーキテクチャ制約のセットから成ります。個別にこれらの制約のそれぞれを考えることもできますが、一般的なアーキテクチャスタイルからの派生という観点でこれらを説明すると、選択の背後にある原理を理解しやすくなります。図5-9では、第3章で分析したネットワークベースのアーキテクチャスタイルに関して、RESTの制約の派生を示します。
図5-9: 制約のスタイルによるREST 派生
