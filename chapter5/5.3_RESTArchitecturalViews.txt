5.3 RESTアーキテクチャビュー

RESTアーキテクチャ要素の理解が分断されているので、要素が構造を形成するためにどのようにはたらくかを説明するために、アーキテクチャビュー［105］を使用します。3つのタイプのビュー――プロセス、コネクタ、およびデータ――は、RESTの設計原理を照らし出す上で役に立ちます。

5.3.1 プロセスビュー

アーキテクチャのプロセスビューは、システムを流れるデータの経路を明らかにすることによって、コンポーネントの相互作用関係を導き出すという点で、主に有効です。残念ながら、通常、実際のシステムの相互作用は、詳細によって覆い隠された全体図に行き着く大規模な数のコンポーネントにかかわります。図5-10では、RESTベースアーキテクチャから、3つの並行リクエストを処理する間の特定インスタンスでのプロセスビューの例を提供します。

図5-10: RESTベースアーキテクチャのプロセスビュー

RESTにおけるクライアント・サーバの関心事の分離は、コンポーネントの実装を簡素化し、コネクタ意味論の複雑さを減少させて、パフォーマンスチューニングの有効性を向上させるとともに、純粋なサーバコンポーネントのスケーラビリティを増強します。レイヤー構造の制約は、仲介者（プロキシ、ゲートウェイ、およびファイアウォール）がコンポーネント間のインタフェースを変えることなく、やり取りの様々なポイントで紹介されることを実現します。その結果、コミュニケーションの翻訳を助けたり、大規模な共有されたキャッシュを通してパフォーマンスを向上させたりします。RESTは、自己記述的になるようにメッセージを制限することで、中間的な処理を可能にします。リクエスト間の相互作用はステートレスです。標準的な方法とメディアタイプは、意味論を表現することと情報交換をすることに使われます。そして、レスポンスは、キャッシュ可能性を明確に示します。

コンポーネントが直接接続されるので、特定のアプリケーション動作のそれらの準備と機能は、パイプ＆フィルタスタイルと同様の特性を持っています。RESTのコンポーネントは双方向のストリームで交信しますが、それぞれの方向の処理は独立しており、その結果、ストリームの変換器（フィルタ）に影響を受けやすいです。一般的なコネクタインタフェースは、コンポーネントがそれぞれのリクエストあるいはレスポンスの特性に基づいて、ストリームに配置されることを実現します。

サービスは、仲介者の複雑な階層構造を使って、複数の分散された発信元サーバで実装されるかもしれません。RESTのステートレス性は、総合的なコンポーネント接続形態を意識する必要性と、インターネット・スケールアーキテクチャのために不可能なタスクを取り除き、それぞれの相互作用が他から独立することを実現します。コンポーネントが、それぞれの目的地か仲介者のどちらかとして機能するのをリクエスト対象によって動的に決定することを許容します。コネクタは、パフォーマンス上の理由で他のコンポーネントの存在と能力をキャッシュするかもしれませんが、それらのコミュニケーションのスコープの間だけお互いの存在を意識すれば済みます。

5.3.2 コネクタビュー

アーキテクチャのコネクタビューは、コンポーネント間のコミュニケーション構造に力を入れます。RESTベースのアーキテクチャでは、一般的なリソースインタフェースを定義する制約が、特に興味深いです。

クライアントコネクタは、各リクエストに適切なコミュニケーションメカニズムを選択するために、リソース識別子を調べます。例えば、クライアントは、おそらくある物が注釈フィルタとして機能して、識別子がそれをローカルリソースであると示すとき、特定のプロキシコンポーネントへ接続するために構成されるかもしれません。同様に、識別子の何らかの部分集合へのリクエストを拒絶するようにも、クライアントを構成できます。

RESTはコミュニケーションを特定のプロトコルに制限しませんが、コンポーネントの間のインタフェースと、コンポーネントの間で行われ得る相互作用と実装の前提の範囲を制約します。例えば、Webのプライマリ転送プロトコルはHTTPですが、アーキテクチャはネットワークサーバを先在させると発生するリソースへのシームレスなアクセス――FTP［107］、Gopher［7］、WAIS［36］など――を含んでいます。それらのサービスとの相互作用は、RESTコネクタの意味論に制限されます。この制約は、コネクタ意味論のための一般的なインタフェースという単独のメリットを維持するために、例えばWAISのような関連フィードバックプロトコルのステートフルな相互作用といった他のアーキテクチャのメリットのいくつかを犠牲にします。代わりに、一般的なインタフェースによって、単独プロキシを通して数多くのサービスにアクセスすることを可能にします。アプリケーションが別のアーキテクチャの追加機能を必要とする場合、Webアーキテクチャが"telnet"と"mailto"リソースに連結する方法と同様に、並行に実行する別々のシステムとしてそれらの能力を実装して、呼び出すことができます。

5.3.3 データビュー

アーキテクチャのデータビューは、コンポーネントを通して流れる情報としてのアプリケーション状態を明らかにします。RESTは明確に分散情報システムをターゲットにしているため、アプリケーションを、ユーザが好きなタスクを実行することを通じて情報とコントロールの代替手段の凝集性がある構造とみなします。例えば、オンライン辞書での単語検索は、仮想博物館を通る旅行をする、または、試験勉強のためにクラスのノートのセットを見直す、1つのアプリケーションです。各アプリケーションは、基本的なシステムのゴールを定義し、システムの性能を測定できます。

コンポーネントの相互作用は、メッセージを動的にサイズで分けた形で起こります。小さい、あるいは、中くらいの大きさの粒度のメッセージは意味論の制御に使用されますが、アプリケーションのタスクの大半は、完全なリソースの表現を含む大きな粒度のメッセージによって達成されます。最も頻繁なフォームのリクエストのセマンティクスは、リソースの表現を検索するもの（たとえば「GET」HTTPメソッド）です。これは、よく後で再利用するためにキャッシュされます。

RESTは、相互作用の応答で受け取った表現に、制御状態のすべてを集約します。その目標は、サーバが現在のリクエストを超えてクライアントの状態を認識し続ける必要性を排除することによって、サーバのスケーラビリティを改善することです。したがって、アプリケーション状態は、保留のリクエスト、接続されたコンポーネントの位相（それらのいくつかはバッファデータをフィルタリングしているかもしれません）、それらのコネクタに関するアクティブなリクエスト、それらのリクエストに応答した表現に関するデータフロー、およびユーザエージェントによって受信できるようなそれらの表現の処理などにより、定義されます。

未処理のリクエストがない時はいつも、アプリケーションは安定状態に達します。すなわち、それは、どのような保留のリクエストもなく、現在のリクエストのセットへの応答のすべてを完全に受信したか、表現のデータ・ストリームとしてそれらを扱うことができるポイントを受信したということです。ブラウザアプリケーションのために、この状態は「Webページ」に対応しており、プライマリ表現と付属の表現――インラインイメージ、埋込みアプレット、スタイルシートなどのようなもの――を含んでいます。アプリケーションの安定状態の意義は、ユーザが体感するパフォーマンスとネットワークリクエストトラフィックの爆発の両方への影響にみられます。

ブラウザアプリケーションのユーザ体感パフォーマンスは、安定状態の間のレイテンシによって決まります。それは、1つのWebページでハイパーメディアリンクを選択した時点と、使用可能な情報が次のWebページにレンダリングされた時点の間の時間のことです。したがって、この通信の待ち時間を減少させることが、ブラウザパフォーマンスの最適化では中心となります。

RESTベースのアーキテクチャは、主としてリソースの表現の転送でやり取りするので、通信プロトコルの設計と、表現データフォーマットの設計の両方によって、レイテンシに影響を与えることができます。それが受信されている時にレスポンスデータを増幅して表わす能力は、それぞれの表現でのメディアタイプの設計とレイアウト情報の利用性（インラインオブジェクトの見えるサイズ）により、決まります。

興味深いことに、最も効率的なネットワークリクエストは、ネットワークを使用しないものにおいて見られます。言い換えれば、キャッシュされたレスポンスを再利用する能力は、アプリケーションパフォーマンスにかなりの改善をもたらします。キャッシュの使用は、検索のオーバーヘッドのためにそれぞれの個別のリクエストにいくらかのレイテンシを加えますが、リクエストのほんの数パーセントが使用可能なキャッシュにヒットするだけでも、リクエストレイテンシの平均はかなり減少します。

アプリケーションの次の制御状態に、最初に要求されたリソースの表現が属しているので、その最初の表現を得ることが優先です。したがって、RESTの相互作用は、「最初にレスポンスして、後から考える」プロトコルによって改良されます。言い換えれば、コンテンツのレスポンスを送る前に交渉する機能のようなもののために、ユーザアクションごとの多重の相互作用を必要とするプロトコルは、何でも送信するプロトコルよりも体感できるほど遅いです。最初に最適になるようにし、最初のレスポンスが不十分であれば、クライアントに検索のための代替手段のリストを提供します。

アプリケーション状態が制御されて、ユーザエージェントによって保存されることは、複数サーバからの表現の構成で可能です。状態を保存するというスケーラビリティの問題からサーバを解放することに加えて、ユーザが状態（たとえば、Webブラウザの履歴）を直接操作し、その状態の変化を予期して（たとえば、リンクマップと表現の先読み）、1つのアプリケーションから別のもの（たとえば、ブックマークとURIエントリの対話）へジャンプすることを可能にします。

したがって、モデルアプリケーションは、1つの状態から次の状態まで、検査と、表現の現在セットの代替状態変遷の中から選択することで移行する、エンジンです。当然ながら、これはまさにハイパーメディアブラウザのユーザインタフェースに合っています。しかしながら、そのスタイルは、すべてのアプリケーションがブラウザであると仮定しません。実際に、アプリケーションの詳細は標準的なコネクタインタフェースによってサーバから隠されており、その結果、ユーザエージェントは、インデックス作成サービスや、ある評価基準に合ったデータを探している個人的なエージェント、または廃れた参照の情報や変更されたコンテンツをパトロールすることで忙しいメンテナンス・スパイダー［39］などのために情報検索を実行する自動化されたロボットと同等になりました。

